/*!
 * accounting.js v0.4.1
 * Copyright 2014 Open Exchange Rates
 *
 * Freely distributable under the MIT license.
 * Portions of accounting.js are inspired or borrowed from underscore.js
 *
 * Full details and documentation:
 * http://openexchangerates.github.io/accounting.js/
 */
!function(n,r){/**
	 * Tests whether supplied parameter is a string
	 * from underscore.js
	 */
function e(n){return!!(""===n||n&&n.charCodeAt&&n.substr)}/**
	 * Tests whether supplied parameter is a string
	 * from underscore.js, delegates to ECMA5's native Array.isArray
	 */
function t(n){return p?p(n):"[object Array]"===l.call(n)}/**
	 * Tests whether supplied parameter is a true object
	 */
function o(n){return n&&"[object Object]"===l.call(n)}/**
	 * Extends an object with a defaults object, similar to underscore's _.defaults
	 *
	 * Used for abstracting parameter handling from API methods
	 */
function a(n,r){var e;n=n||{},r=r||{};
// Iterate over object non-prototype properties:
for(e in r)r.hasOwnProperty(e)&&null==n[e]&&(n[e]=r[e]);return n}/**
	 * Implementation of `Array.map()` for iteration loops
	 *
	 * Returns a new Array as a result of calling `iterator` on each array value.
	 * Defers to native Array.map if available
	 */
function i(n,r,e){var t,o,a=[];if(!n)return a;
// Use native .map method if it exists:
if(f&&n.map===f)return n.map(r,e);
// Fallback for native .map:
for(t=0,o=n.length;o>t;t++)a[t]=r.call(e,n[t],t,n);return a}/**
	 * Check and normalise the value of precision (must be positive integer)
	 */
function u(n,r){return n=Math.round(Math.abs(n)),isNaN(n)?r:n}/**
	 * Parses a format string or object and returns format obj for use in rendering
	 *
	 * `format` is either a string with the default (positive) format, or object
	 * containing `pos` (required), `neg` and `zero` values (or a function returning
	 * either a string or object)
	 *
	 * Either string or format.pos must contain "%v" (value) to be valid
	 */
function c(n){var r=s.settings.currency.format;
// Format can be a string, in which case `value` ("%v") must be present:
// Allow function as format parameter (should return string or object):
// Format can be a string, in which case `value` ("%v") must be present:
return"function"==typeof n&&(n=n()),e(n)&&n.match("%v")?{pos:n,neg:n.replace("-","").replace("%v","-%v"),zero:n}:n&&n.pos&&n.pos.match("%v")?n:e(r)?s.settings.currency.format={pos:r,neg:r.replace("%v","-%v"),zero:r}:r}/* --- Setup --- */
// Create the local library object, to be exported or referenced globally later
var s={};
// Current version
s.version="0.4.1",/* --- Exposed settings --- */
// The library's settings configuration object. Contains default parameters for
// currency and number formatting
s.settings={currency:{symbol:"$",// default currency symbol is '$'
format:"%s%v",// controls output: %s = symbol, %v = value (can be object, see docs)
decimal:".",// decimal point separator
thousand:",",// thousands separator
precision:2,// decimal places
grouping:3},number:{precision:0,// default precision on numbers is 0
grouping:3,// digit grouping (not implemented yet)
thousand:",",decimal:"."}};/* --- Internal Helper Methods --- */
// Store reference to possibly-available ECMAScript 5 methods for later
var f=Array.prototype.map,p=Array.isArray,l=Object.prototype.toString,m=s.unformat=s.parse=function(n,r){
// Recursively unformat arrays:
if(t(n))return i(n,function(n){return m(n,r)});
// Return the value as-is if it's already a number:
if(
// Fails silently (need decent errors):
n=n||0,"number"==typeof n)return n;
// Default decimal point comes from settings, but could be set to eg. "," in opts:
r=r||s.settings.number.decimal;
// Build regex to strip out everything except digits, decimal point and minus sign:
var e=new RegExp("[^0-9-"+r+"]",["g"]),o=parseFloat((""+n).replace(/\((.*)\)/,"-$1").replace(e,"").replace(r,"."));
// This will fail silently which may cause trouble, let's wait and see:
return isNaN(o)?0:o},d=s.toFixed=function(n,r){r=u(r,s.settings.number.precision);var e=Math.pow(10,r);
// Multiply up by precision, round accurately, then divide and use native toFixed():
return(Math.round(s.unformat(n)*e)/e).toFixed(r)},g=s.formatNumber=s.format=function(n,r,e,c){
// Resursively format arrays:
if(t(n))return i(n,function(n){return g(n,r,e,c)});
// Clean up number:
n=m(n);
// Build options object from second param (if object) or all params, extending defaults:
var f=a(o(r)?r:{precision:r,thousand:e,decimal:c},s.settings.number),
// Clean up precision
p=u(f.precision),
// Do some calc:
l=0>n?"-":"",h=parseInt(d(Math.abs(n||0),p),10)+"",y=h.length>3?h.length%3:0;
// Format the number:
return l+(y?h.substr(0,y)+f.thousand:"")+h.substr(y).replace(/(\d{3})(?=\d)/g,"$1"+f.thousand)+(p?f.decimal+d(Math.abs(n),p).split(".")[1]:"")},h=s.formatMoney=function(n,r,e,f,p,l){
// Resursively format arrays:
if(t(n))return i(n,function(n){return h(n,r,e,f,p,l)});
// Clean up number:
n=m(n);
// Build options object from second param (if object) or all params, extending defaults:
var d=a(o(r)?r:{symbol:r,precision:e,thousand:f,decimal:p,format:l},s.settings.currency),
// Check format (returns object with pos, neg and zero):
y=c(d.format),
// Choose which format to use for this value:
b=n>0?y.pos:0>n?y.neg:y.zero;
// Return with currency symbol added:
return b.replace("%s",d.symbol).replace("%v",g(Math.abs(n),u(d.precision),d.thousand,d.decimal))};/**
	 * Format a list of numbers into an accounting column, padding with whitespace
	 * to line up currency symbols, thousand separators and decimals places
	 *
	 * List should be an array of numbers
	 * Second parameter can be an object containing keys that match the params
	 *
	 * Returns array of accouting-formatted number strings of same length
	 *
	 * NB: `white-space:pre` CSS rule is required on the list container to prevent
	 * browsers from collapsing the whitespace in the output strings.
	 */
s.formatColumn=function(n,r,f,p,l,d){if(!n)return[];
// Build options object from second param (if object) or all params, extending defaults:
var h=a(o(r)?r:{symbol:r,precision:f,thousand:p,decimal:l,format:d},s.settings.currency),
// Check format (returns object with pos, neg and zero), only need pos for now:
y=c(h.format),
// Whether to pad at start of string or after currency symbol:
b=y.pos.indexOf("%s")<y.pos.indexOf("%v")?!0:!1,
// Store value for the length of the longest string in the column:
v=0,
// Format the list according to options, store the length of the longest string:
x=i(n,function(n,r){if(t(n))
// Recursively format columns if list is a multi-dimensional array:
return s.formatColumn(n,h);
// Clean up the value
n=m(n);
// Choose which format to use for this value (pos, neg or zero):
var e=n>0?y.pos:0>n?y.neg:y.zero,
// Format this value, push into formatted list and save the length:
o=e.replace("%s",h.symbol).replace("%v",g(Math.abs(n),u(h.precision),h.thousand,h.decimal));return o.length>v&&(v=o.length),o});
// Pad each number in the list and send back the column of numbers:
return i(x,function(n,r){
// Only if this is a string (not a nested array, which would have already been padded):
// Only if this is a string (not a nested array, which would have already been padded):
return e(n)&&n.length<v?b?n.replace(h.symbol,h.symbol+new Array(v-n.length+1).join(" ")):new Array(v-n.length+1).join(" ")+n:n})},/* --- Module Definition --- */
// Export accounting for CommonJS. If being loaded as an AMD module, define it as such.
// Otherwise, just add `accounting` to the global object
"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=s),exports.accounting=s):"function"==typeof define&&define.amd?
// Return the library as an AMD module:
define([],function(){return s}):(
// Use accounting.noConflict to restore `accounting` back to its original value.
// Returns a reference to the library's `accounting` object;
// e.g. `var numbers = accounting.noConflict();`
s.noConflict=function(e){return function(){
// Return reference to the library to re-assign it:
// Reset the value of the root's `accounting` variable:
// Delete the noConflict method:
return n.accounting=e,s.noConflict=r,s}}(n.accounting),
// Declare `fx` on the root (global/window) object:
n.accounting=s)}(this);